---
// src/components/WebVitals/WebVitalsBatchedGA4.astro
export interface Props {
  gaId?: string;
  enableAnalytics?: boolean;
}

const { gaId, enableAnalytics = true } = Astro.props;
const isDev = import.meta.env.DEV;
---

<!-- Set global variables for the module script to use -->
<script define:vars={{ gaId, enableAnalytics, isDev }}>
  // Make config available globally for the module script
  window.webVitalsConfig = { gaId, enableAnalytics, isDev };
</script>
<script>
  import { onCLS, onINP, onLCP, onFCP, onTTFB } from "web-vitals/attribution";

  // Get config from global variables set by Astro
  const config = window.webVitalsConfig || {};
  const { gaId, enableAnalytics = true, isDev = false } = config;

  // Determine which GA ID to use
  const currentGaId = gaId;

  // Check if we should run analytics in current environment
  const shouldRunAnalytics = enableAnalytics;

  const queue = new Set();
  let flushTimer = null;

  function addToQueue(metric) {
    if (!shouldRunAnalytics) {
      if (isDev) {
        console.log("ðŸ” Web Vitals (DEV):", {
          name: metric.name,
          value: metric.value,
          rating: metric.rating,
          attribution: metric.attribution,
        });
      }
      return;
    }

    // Create enhanced metric object with attribution data
    const enhancedMetric = {
      // Standard metric properties
      name: metric.name,
      value: metric.value,
      delta: metric.delta,
      id: metric.id,
      rating: metric.rating,
      navigationType: metric.navigationType,

      // Add environment context
      environment: isDev ? "development" : "production",
      hostname: window.location.hostname,

      // Add attribution-specific data based on metric type
      ...getAttributionData(metric),

      // Timestamp for when this metric was captured
      timestamp: Date.now(),
    };

    queue.add(enhancedMetric);

    // Optional: Set a timeout to flush queue if page stays open too long
    clearTimeout(flushTimer);
    flushTimer = setTimeout(flushQueue, isDev ? 10000 : 30000); // Shorter flush in dev
  }

  function getAttributionData(metric) {
    const { name, attribution } = metric;
    const attributionData = {};

    switch (name) {
      case "CLS":
        if (attribution) {
          attributionData.debug_target =
            attribution.largestShiftTarget || "unknown";
          attributionData.largest_shift_time = attribution.largestShiftTime;
          attributionData.largest_shift_value = attribution.largestShiftValue;
          attributionData.load_state = attribution.loadState;
        }
        break;

      case "INP":
        if (attribution) {
          attributionData.debug_target =
            attribution.interactionTarget || "unknown";
          attributionData.interaction_type = attribution.interactionType;
          attributionData.interaction_time = attribution.interactionTime;
          attributionData.input_delay = attribution.inputDelay;
          attributionData.processing_duration = attribution.processingDuration;
          attributionData.presentation_delay = attribution.presentationDelay;
          attributionData.load_state = attribution.loadState;
        }
        break;

      case "LCP":
        if (attribution) {
          attributionData.debug_target = attribution.element || "unknown";
          attributionData.resource_url = attribution.url;
          attributionData.time_to_first_byte = attribution.timeToFirstByte;
          attributionData.resource_load_delay = attribution.resourceLoadDelay;
          attributionData.resource_load_duration =
            attribution.resourceLoadDuration;
          attributionData.element_render_delay = attribution.elementRenderDelay;
        }
        break;

      case "FCP":
        if (attribution) {
          attributionData.time_to_first_byte = attribution.timeToFirstByte;
          attributionData.first_byte_to_fcp = attribution.firstByteToFCP;
          attributionData.load_state = attribution.loadState;
        }
        break;

      case "TTFB":
        if (attribution) {
          attributionData.waiting_duration = attribution.waitingDuration;
          attributionData.cache_duration = attribution.cacheDuration;
          attributionData.dns_duration = attribution.dnsDuration;
          attributionData.connection_duration = attribution.connectionDuration;
          attributionData.request_duration = attribution.requestDuration;
        }
        break;
    }

    return attributionData;
  }

  function flushQueue() {
    if (queue.size === 0) return;

    clearTimeout(flushTimer);

    // Convert Set to Array for processing
    const metrics = Array.from(queue);

    if (isDev) {
      console.group(`ðŸ“Š Flushing ${metrics.length} Web Vitals metrics`);
      console.table(
        metrics.map((m) => ({
          name: m.name,
          value: m.value,
          rating: m.rating,
          debug_target: m.debug_target || "N/A",
          environment: m.environment,
        }))
      );
      console.groupEnd();
    }

    // Send to Google Analytics 4
    if (shouldRunAnalytics) {
      sendToGA4(metrics);
    }

    // Optional: Also send to custom analytics endpoint
    if (shouldRunAnalytics || isDev) {
      sendToCustomEndpoint(metrics);
    }

    // Clear the queue
    queue.clear();
  }

  function sendToGA4(metrics) {
    // Check if gtag is available, if not, wait for it
    if (typeof gtag === "undefined") {
      if (isDev) {
        console.log("â³ Waiting for gtag to load...");
      }

      // Wait for gtag to be available, then retry
      const checkGtag = () => {
        if (typeof gtag !== "undefined") {
          sendToGA4(metrics);
        } else {
          // Retry after a short delay, up to 10 times (5 seconds total)
          setTimeout(checkGtag, 500);
        }
      };

      setTimeout(checkGtag, 100);
      return;
    }

    // Send each metric as a separate event to GA4
    metrics.forEach((metric) => {
      const eventParams = {
        // Standard GA4 event parameters
        value: metric.delta, // Use delta so values can be summed

        // Custom parameters for the metric
        metric_id: metric.id,
        metric_value: metric.value,
        metric_delta: metric.delta,
        metric_rating: metric.rating,
        navigation_type: metric.navigationType,
        environment: metric.environment,
        hostname: metric.hostname,

        // Attribution data (flatten the object)
        ...Object.fromEntries(
          Object.entries(metric)
            .filter(
              ([key]) =>
                ![
                  "name",
                  "value",
                  "delta",
                  "id",
                  "rating",
                  "navigationType",
                  "timestamp",
                  "environment",
                  "hostname",
                ].includes(key)
            )
            .map(([key, value]) => [key, value])
        ),
      };

      // Send to GA4
      gtag("event", metric.name, eventParams);
    });

    if (isDev) {
      console.log(`âœ… Sent ${metrics.length} metrics to GA4 (${currentGaId})`);
    }
  }

  function sendToCustomEndpoint(metrics) {
    // Optional: Send batched data to your own analytics endpoint
    const body = JSON.stringify({
      metrics: metrics,
      page_url: window.location.href,
      user_agent: navigator.userAgent,
      timestamp: Date.now(),
      environment: isDev ? "development" : "production",
    });

    const endpoint = isDev ? "/api/analytics-dev" : "/api/analytics";

    // Use sendBeacon for reliability during page unload
    if (navigator.sendBeacon) {
      navigator.sendBeacon(endpoint, body);
    } else {
      // Fallback for browsers without sendBeacon
      fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: body,
        keepalive: true,
      }).catch((error) => {
        if (isDev) {
          console.warn("Failed to send metrics to custom endpoint:", error);
        }
      });
    }
  }

  // Wait for page to be fully loaded and GA to be available before initializing
  function initializeWebVitals() {
    // Set up metric collection - only if analytics should run
    if (shouldRunAnalytics || isDev) {
      onCLS(addToQueue, { reportAllChanges: true });
      onINP(addToQueue, { reportAllChanges: true });
      onLCP(addToQueue, { reportAllChanges: true });
      onFCP(addToQueue);
      onTTFB(addToQueue);

      if (isDev) {
        console.log("ðŸš€ Web Vitals tracking initialized:", {
          environment: "development",
          gaId: currentGaId || "none",
          analyticsEnabled: shouldRunAnalytics,
        });
      }
    }

    // Flush queue when page becomes hidden
    addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        flushQueue();
      }
    });

    // Flush queue before page unloads (fallback)
    addEventListener("beforeunload", flushQueue);

    // Optional: Flush queue when user becomes idle (shorter timeout in dev)
    let idleTimer;
    function resetIdleTimer() {
      clearTimeout(idleTimer);
      idleTimer = setTimeout(
        () => {
          if (queue.size > 0) {
            if (isDev) {
              console.log("â° Flushing queue due to user inactivity");
            }
            flushQueue();
          }
        },
        isDev ? 30000 : 60000
      ); // 30s in dev, 1min in prod
    }

    // Reset idle timer on user activity
    ["mousedown", "mousemove", "keypress", "scroll", "touchstart"].forEach(
      (event) => {
        addEventListener(event, resetIdleTimer, { passive: true });
      }
    );

    // Start idle timer
    resetIdleTimer();
  }

  // Wait for DOM and GA to be ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(initializeWebVitals, 100); // Small delay to let GA load
    });
  } else {
    setTimeout(initializeWebVitals, 100);
  }
</script>
